# 适配器模式（Adapter Pattern）

## 1. 模式概述
适配器模式是一种结构型设计模式，它将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。

### 1.1 核心意图
- 将一个类的接口转换成客户期望的另一个接口
- 解决接口不兼容问题，使原本因接口不匹配而无法一起工作的类能够协同工作
- 实现客户端和被适配者之间的解耦

### 1.2 典型应用场景
- 系统需要使用现有的类，但这些类的接口不符合系统的需要
- 希望建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类一起工作
- 需要一个统一的输出接口，而输入端的类型不可预知

## 2. 模式结构

### 2.1 角色定义

| 角色 | 职责 | 实现类 |
|------|------|--------|
| **目标接口(Target)** | 定义客户端期望的接口 | ComputerPower |
| **被适配者(Adaptee)** | 定义一个已存在的接口，这个接口需要被适配 | CommonPower |
| **适配器(Adapter)** | 实现目标接口，并持有被适配者的引用，将被适配者的接口转换为目标接口 | ThinkPadPower |
| **客户端(Client)** | 使用目标接口与适配器进行交互 | App |

### 2.2 结构示意图

```
┌──────────────────┐        ┌──────────────────┐
│  Target          │        │  Adapter         │
├──────────────────┤        ├──────────────────┤
│ +request()       │        │ +request()       │
└─────────────┬────┘        └─────────────┬────┘
              │                           │
┌─────────────┴────┐            ┌─────────┴─────────┐
│ Client           │            │ Adaptee           │
├──────────────────┤            ├──────────────────┤
│ +useTarget()     │            │ +specificRequest()│
└──────────────────┘            └──────────────────┘
```

## 3. 实现示例

### 3.1 目标接口
```java
public interface ComputerPower {
    int getPower();
}
```

### 3.2 被适配者
```java
public class CommonPower {
    public int getPower() {
        return 220;
    }
}
```

### 3.3 适配器
```java
public class ThinkPadPower implements ComputerPower {
    private CommonPower commonPower;
    
    public ThinkPadPower(CommonPower commonPower) {
        this.commonPower = commonPower;
    }
    
    @Override
    public int getPower() {
        return (commonPower.getPower() / Integer.valueOf(100));
    }
}
```

### 3.4 客户端代码
```java
public class App {
    public static void main(String[] args) {
        CommonPower commonPower = new CommonPower();
        ComputerPower computerPower = new ThinkPadPower(commonPower);
        System.out.println("电脑获得的电压：" + computerPower.getPower() + "V");
    }
}
```

## 4. 优缺点分析

### 4.1 优点
- **兼容性**：可以让原本不兼容的接口协同工作
- **复用性**：可以复用现有的类，无需修改其源代码
- **灵活性**：可以在不修改现有代码的情况下扩展系统功能
- **解耦性**：客户端与被适配者解耦，提高了代码的可维护性

### 4.2 缺点
- **增加了系统的复杂性**：需要额外的适配器类
- **降低了代码的可读性**：过多的适配器可能会导致代码结构混乱

## 5. 标准化规范

### 5.1 命名规范
- 目标接口：通常以接口功能命名
- 被适配者：以现有实现类的名称命名
- 适配器：通常以"Adapter"结尾，或包含被适配者和目标接口的名称

### 5.2 代码规范
- 适配器应实现目标接口
- 适配器应持有被适配者的引用
- 适配器应将目标接口的方法转换为被适配者的方法调用
- 客户端应只与目标接口交互

### 5.3 最佳实践
- 当需要使用现有的类，但接口不符合需求时使用适配器模式
- 优先使用对象适配器（组合方式）而不是类适配器（继承方式）
- 适配器应保持简单，只负责接口转换

## 6. 与其他模式的比较

### 6.1 适配器模式 vs 外观模式
- 适配器模式：将一个接口转换为另一个接口，使不兼容的类可以一起工作
- 外观模式：为子系统提供一个统一的接口，简化客户端的使用

### 6.2 适配器模式 vs 桥接模式
- 适配器模式：用于连接已经存在的接口
- 桥接模式：用于分离抽象和实现，使它们可以独立变化

### 6.3 适配器模式 vs 代理模式
- 适配器模式：改变接口的形式
- 代理模式：保留原始接口，增加额外的功能

## 7. 总结

适配器模式是一种强大的结构型设计模式，它可以解决接口不兼容的问题，使原本无法一起工作的类能够协同工作。在系统集成和代码复用场景中，适配器模式是一个理想的选择。

使用适配器模式时，需要明确目标接口、被适配者和适配器的关系，并根据实际情况选择合适的适配器实现方式。遵循标准化的命名和代码规范，可以使适配器模式的实现更加清晰和易于理解。