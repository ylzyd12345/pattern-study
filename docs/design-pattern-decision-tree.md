# 设计模式决策树

## 🌳 如何选择合适的设计模式

这个决策树将帮助你根据具体场景选择最适合的设计模式。

---

## 📋 快速导航

- [创建型模式决策树](#创建型模式决策树)
- [结构型模式决策树](#结构型模式决策树)
- [行为型模式决策树](#行为型模式决策树)
- [模式对比表](#模式对比表)
- [实际应用场景](#实际应用场景)

---

## 🏗️ 创建型模式决策树

### Q1: 你需要控制对象的创建过程吗？

#### 📍 是 → Q2: 你需要确保一个类只有一个实例吗？
- **是** → **单例模式 (Singleton)**
  - 🎯 **场景**: 配置管理器、日志记录器、数据库连接池
  - ⚠️ **注意**: 考虑线程安全和测试困难性
  - 📖 **示例**: `Runtime.getRuntime()`, Spring的默认Bean作用域

- **否** → Q3: 你需要创建相关或依赖对象的家族吗？
  - **是** → **抽象工厂模式 (Abstract Factory)**
    - 🎯 **场景**: 跨平台UI工具包、数据库访问层
    - ⚠️ **注意**: 产品族扩展困难
    - 📖 **示例**: JDBC Driver Manager, Spring BeanFactory

  - **否** → Q4: 你需要将复杂对象的构建与表示分离吗？
    - **是** → **建造者模式 (Builder)**
      - 🎯 **场景**: 构建复杂对象、可选参数很多
      - ⚠️ **注意**: 增加类的数量
      - 📖 **示例**: StringBuilder, SpringApplicationBuilder

    - **否** → Q5: 你需要通过复制现有对象来创建新对象吗？
      - **是** → **原型模式 (Prototype)**
        - 🎯 **场景**: 创建成本高、需要动态配置
        - ⚠️ **注意**: 深拷贝实现复杂
        - 📖 **示例**: Object.clone(), Spring BeanDefinition

      - **否** → **工厂方法模式 (Factory Method)**
        - 🎯 **场景**: 需要灵活创建对象、不想依赖具体类
        - ⚠️ **注意**: 增加类的数量
        - 📖 **示例**: Calendar.getInstance(), @Bean注解

#### 📍 否 → 考虑使用构造函数直接创建对象

---

## 🔧 结构型模式决策树

### Q1: 你需要处理类或对象的组合关系吗？

#### 📍 是 → Q2: 你需要在不改变接口的情况下扩展功能吗？
- **是** → **装饰器模式 (Decorator)**
  - 🎯 **场景**: 动态添加功能、IO流处理
  - ⚠️ **注意**: 增加小对象数量
  - 📖 **示例**: BufferedReader, Java IO流, Filter链

- **否** → Q3: 你需要将对象组合成树形结构吗？
  - **是** → **组合模式 (Composite)**
    - 🎯 **场景**: 文件系统、GUI组件、组织架构
    - ⚠️ **注意**: 限制组件类型
    - 📖 **示例**: AWT Container, XML DOM

  - **否** → Q4: 你需要简化复杂子系统的使用吗？
    - **是** → **外观模式 (Facade)**
      - 🎯 **场景**: 简化API、系统解耦
      - ⚠️ **注意**: 可能成为单一故障点
      - 📖 **示例**: JDBCTemplate, Spring Boot AutoConfiguration

    - **否** → Q5: 你需要为其他对象提供代理以控制访问吗？
      - **是** → **代理模式 (Proxy)**
        - 🎯 **场景**: 访问控制、延迟加载、远程访问
        - ⚠️ **注意**: 增加调用层级
        - 📖 **示例**: 动态代理, Spring AOP, @Transactional

      - **否** → Q6: 你需要将抽象与实现分离吗？
        - **是** → **桥接模式 (Bridge)**
          - 🎯 **场景**: 多维度扩展、平台独立
          - ⚠️ **注意**: 增加复杂度
          - 📖 **示例**: JDBC Driver, JdbcTemplate

        - **否** → Q7: 你需要将一个类的接口转换成另一个接口吗？
          - **是** → **适配器模式 (Adapter)**
            - 🎯 **场景**: 接口不兼容、复用现有代码
            - ⚠️ **注意**: 增加系统复杂度
            - 📖 **示例**: InputStreamReader, HandlerAdapter

          - **否** → Q8: 你需要通过共享技术支持大量细粒度对象吗？
            - **是** → **享元模式 (Flyweight)**
              - 🎯 **场景**: 内存优化、大量相似对象
              - ⚠️ **注意**: 需要维护对象池
              - 📖 **示例**: Integer.valueOf(), String常量池

            - **否** → 考虑直接组合对象

#### 📍 否 → 考虑使用继承或组合

---

## 🎭 行为型模式决策树

### Q1: 你需要处理对象间的通信和交互吗？

#### 📍 是 → Q2: 你需要定义对象间的一对多依赖关系吗？
- **是** → **观察者模式 (Observer)**
  - 🎯 **场景**: 事件驱动、状态变化通知
  - ⚠️ **注意**: 可能导致循环依赖
  - 📖 **示例**: EventListener, ApplicationEvent, MVC

- **否** → Q3: 你需要将请求封装成对象吗？
  - **是** → **命令模式 (Command)**
    - 🎯 **场景**: 撤销重做、事务、队列
    - ⚠️ **注意**: 增加类的数量
    - 📖 **示例**: Runnable, TransactionTemplate

  - **否** → Q4: 你需要使多个对象都有机会处理请求吗？
    - **是** → **责任链模式 (Chain of Responsibility)**
      - 🎯 **场景**: 过滤器链、异常处理
      - ⚠️ **注意**: 请求可能不被处理
      - 📖 **示例**: Filter链, Logger, ExceptionHandler

    - **否** → Q5: 你需要定义算法的骨架，将步骤延迟到子类吗？
      - **是** → **模板方法模式 (Template Method)**
        - 🎯 **场景**: 算法骨架固定、步骤可变
        - ⚠️ **注意**: 子类数量增加
        - 📖 **示例**: HttpServlet, JdbcTemplate

      - **否** → Q6: 你需要在运行时切换算法吗？
        - **是** → **策略模式 (Strategy)**
          - 🎯 **场景**: 算法可替换、避免条件语句
          - ⚠️ **注意**: 客户端需要了解策略
          - 📖 **示例**: Comparator, PaymentMethod

        - **否** → Q7: 你需要允许对象在内部状态改变时改变行为吗？
          - **是** → **状态模式 (State)**
            - 🎯 **场景**: 状态机、游戏角色
            - ⚠️ **注意**: 状态管理复杂
            - 📖 **示例**: Thread.State, OrderStatus

          - **否** → Q8: 你需要在不破坏封装性的前提下保存和恢复状态吗？
            - **是** → **备忘录模式 (Memento)**
              - 🎯 **场景**: 撤销操作、游戏存档
              - ⚠️ **注意**: 可能消耗大量内存
              - 📖 **示例**: Serializable, 事务管理

            - **否** → Q9: 你需要用一个中介对象来封装一系列对象交互吗？
              - **是** → **中介者模式 (Mediator)**
                - 🎯 **场景**: 复杂交互、解耦对象
                - ⚠️ **注意**: 中介者可能复杂
                - 📖 **示例**: ChatRoom, Event Bus

              - **否** → Q10: 你需要提供一种方法顺序访问聚合对象而不暴露内部表示吗？
                - **是** → **迭代器模式 (Iterator)**
                  - 🎯 **场景**: 集合遍历、统一接口
                  - ⚠️ **注意**: 增加类的数量
                  - 📖 **示例**: Collection.iterator(), Stream

                  - **否** → Q11: 你需要表示一个作用于某对象结构中的各元素的操作吗？
                    - **是** → **访问者模式 (Visitor)**
                      - 🎯 **场景**: 结构稳定、操作多变
                      - ⚠️ **注意**: 违反封装原则
                      - 📖 **示例**: FileVisitor, Compiler AST

                    - **否** → Q12: 你需要给定一个语言，定义它的文法表示并解释吗？
                      - **是** → **解释器模式 (Interpreter)**
                        - 🎯 **场景**: 特定领域语言、表达式求值
                        - ⚠️ **注意**: 复杂语法实现困难
                        - 📖 **示例**: Regex, SpEL, SQL解析器

                      - **否** → 考虑直接方法调用

#### 📍 否 → 考虑使用直接方法调用或简单组合

---

## 📊 模式对比表

### 创建型模式对比

| 模式 | 目的 | 复杂度 | 扩展性 | 适用场景 |
|------|------|--------|--------|----------|
| 单例 | 确保唯一实例 | 低 | 低 | 全局访问点 |
| 工厂方法 | 创建对象 | 中 | 中 | 灵活创建 |
| 抽象工厂 | 创建产品族 | 高 | 高 | 产品族管理 |
| 建造者 | 构建复杂对象 | 中 | 高 | 复杂对象构建 |
| 原型 | 复制对象 | 中 | 中 | 对象复制 |

### 结构型模式对比

| 模式 | 目的 | 复杂度 | 性能影响 | 适用场景 |
|------|------|--------|----------|----------|
| 适配器 | 接口适配 | 中 | 低 | 接口不兼容 |
| 桥接 | 分离抽象与实现 | 高 | 低 | 多维度扩展 |
| 组合 | 树形结构 | 中 | 中 | 部分-整体结构 |
| 装饰器 | 动态扩展 | 中 | 中 | 功能组合 |
| 外观 | 简化接口 | 低 | 低 | 系统简化 |
| 享元 | 对象共享 | 高 | 高 | 内存优化 |
| 代理 | 访问控制 | 中 | 中 | 访问控制 |

### 行为型模式对比

| 模式 | 目的 | 复杂度 | 耦合度 | 适用场景 |
|------|------|--------|--------|----------|
| 责任链 | 请求处理 | 中 | 低 | 链式处理 |
| 命令 | 请求封装 | 中 | 低 | 撤销重做 |
| 解释器 | 语言解释 | 高 | 中 | DSL |
| 迭代器 | 集合遍历 | 低 | 低 | 统一遍历 |
| 中介者 | 对象协调 | 高 | 低 | 复杂交互 |
| 备忘录 | 状态保存 | 中 | 低 | 撤销操作 |
| 观察者 | 状态通知 | 中 | 中 | 事件驱动 |
| 状态 | 状态行为 | 中 | 中 | 状态机 |
| 策略 | 算法封装 | 低 | 中 | 算法切换 |
| 模板方法 | 算法骨架 | 中 | 高 | 代码复用 |
| 访问者 | 结构操作 | 高 | 低 | 结构稳定 |

---

## 🎯 实际应用场景

### Web开发场景

| 场景 | 推荐模式 | 组合使用 |
|------|----------|----------|
| MVC架构 | 观察者 + 策略 | 视图更新、控制器策略 |
| Filter链 | 责任链 + 装饰器 | 请求处理、功能增强 |
| 依赖注入 | 工厂 + 单例 | Bean创建、实例管理 |
| AOP切面 | 代理 + 装饰器 | 横切关注点 |
| 事务管理 | 命令 + 备忘录 | 事务执行、回滚 |

### 企业应用场景

| 场景 | 推荐模式 | 组合使用 |
|------|----------|----------|
| 数据访问 | 工厂 + 适配器 | 连接创建、接口适配 |
| 缓存系统 | 代理 + 享元 | 访问控制、对象共享 |
| 消息队列 | 观察者 + 命令 | 事件发布、消息封装 |
| 工作流 | 状态 + 责任链 | 状态管理、流程处理 |
| 插件系统 | 装饰器 + 组合 | 功能扩展、组件管理 |

### 移动应用场景

| 场景 | 推荐模式 | 组合使用 |
|------|----------|----------|
| UI组件 | 组合 + 装饰器 | 组件树、功能增强 |
| 网络请求 | 命令 + 观察者 | 请求封装、状态通知 |
| 数据同步 | 备忘录 + 观察者 | 状态保存、变化通知 |
| 主题切换 | 策略 + 观察者 | 主题策略、视图更新 |
| 导航管理 | 状态 + 命令 | 页面状态、导航命令 |

---

## 🔍 选择原则

### ✅ 优先考虑的因素

1. **问题匹配**: 模式是否真正解决了你的问题
2. **复杂度权衡**: 引入模式的复杂度是否值得
3. **团队熟悉度**: 团队是否能理解和维护
4. **性能影响**: 对系统性能的影响是否可接受
5. **扩展需求**: 未来是否需要相关扩展

### ❌ 避免的情况

1. **过度设计**: 简单问题使用复杂模式
2. **模式堆砌**: 为了使用而使用模式
3. **性能敏感**: 对性能要求极高的场景
4. **短期项目**: 生命周期短的项目
5. **团队新手**: 缺乏设计模式经验的团队

---

## 📚 学习建议

### 🎯 学习路径

1. **掌握基础**: 先理解SOLID原则
2. **分类学习**: 按创建型、结构型、行为型分类学习
3. **实践应用**: 在实际项目中尝试使用
4. **对比分析**: 理解相似模式的区别
5. **反模式学习**: 了解什么情况不应该使用

### 🛠️ 实践方法

1. **代码重构**: 从现有代码中识别模式
2. **模式替换**: 用不同模式解决同一问题
3. **性能测试**: 测量模式的性能影响
4. **代码审查**: 在团队中推广模式使用
5. **文档记录**: 记录模式使用经验和教训

---

## 🔗 相关资源

- [23种设计模式详细文档](../README.md#23种设计模式概述)
- [设计模式最佳实践](../FAQ.md)
- [代码示例](../../src/main/java/com/kevin/demo/)
- [测试用例](../../src/test/java/com/kevin/demo/)

---

*最后更新: 2025年12月23日*