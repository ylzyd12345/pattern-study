# 常见问题解答 (FAQ)

本文档收集了学习设计模式过程中的常见问题和解答，帮助你更好地理解和应用设计模式。

## 🎯 基础概念类

### Q1: 什么是设计模式？为什么要学习设计模式？

**A**: 设计模式是软件开发中常见问题的典型解决方案。学习设计模式的好处：
- **提高代码质量**：使代码更灵活、可维护、可重用
- **统一设计语言**：团队成员之间有共同的设计词汇
- **加速开发过程**：避免重复造轮子
- **提升架构能力**：培养良好的设计思维

### Q2: 设计模式和算法有什么区别？

**A**: 
- **算法**：解决特定计算问题的步骤和方法，关注"如何做"
- **设计模式**：解决软件设计问题的通用方案，关注"如何组织代码"

**示例**：
- 算法：快速排序、二分查找
- 设计模式：单例模式、观察者模式

### Q3: 是不是所有代码都应该使用设计模式？

**A**: 不是。设计模式的使用原则：
- **适度使用**：在需要时使用，不滥用
- **问题导向**：有明确的问题才考虑使用模式
- **简单优先**：能用简单方案解决就不用复杂模式

**什么时候不需要设计模式**：
- 代码简单且需求稳定
- 性能要求极高的场景
- 团队成员对模式不熟悉

## 📚 学习方法类

### Q4: 设计模式太多，记不住怎么办？

**A**: 建议采用以下方法：
1. **分类记忆**：按创建型、结构型、行为型分类
2. **关联记忆**：记住模式的口诀
   - 创建型：单抽工建原
   - 结构型：桥代理组装适配，享元回家装饰外观
   - 行为型：访问者写好策略备忘录，观察模板迭代的状态，命令中介解释责任链
3. **实践记忆**：通过实际编码加深理解
4. **定期复习**：制定复习计划

### Q5: 理论都懂了，但实际项目中不知道怎么用？

**A**: 这是常见问题，建议：
1. **从重构开始**：先学会识别代码中的坏味道
2. **小处着手**：从简单的模式开始应用
3. **代码审查**：多看优秀项目的代码
4. **结对编程**：和有经验的同事一起开发
5. **记录总结**：写下每次应用模式的经验

### Q6: 如何判断应该使用哪个设计模式？

**A**: 可以按以下思路判断：
1. **识别问题类型**：是创建对象、组织结构还是处理行为？
2. **分析变化点**：代码中哪些部分可能变化？
3. **考虑约束条件**：性能、复杂度、团队熟悉度等
4. **参考决策树**：使用模式选择决策树辅助

**示例决策流程**：
```
需要创建对象？→ 是 → 需要控制实例数量？→ 单例模式
                → 否 → 需要创建复杂对象？→ 建造者模式
                → 否 → 需要创建产品族？→ 抽象工厂模式
                → 否 → 工厂方法模式
```

## 💻 实践应用类

### Q7: 单例模式在分布式环境下如何保证唯一性？

**A**: 分布式环境下的单例需要特殊处理：

**方案1：分布式锁**
```java
public class DistributedSingleton {
    private static volatile DistributedSingleton instance;
    private static final String LOCK_KEY = "singleton_lock";
    
    public static DistributedSingleton getInstance() {
        if (instance == null) {
            synchronized (DistributedSingleton.class) {
                if (instance == null) {
                    // 使用Redis分布式锁
                    if (tryLock(LOCK_KEY)) {
                        try {
                            if (instance == null) {
                                instance = new DistributedSingleton();
                            }
                        } finally {
                            releaseLock(LOCK_KEY);
                        }
                    }
                }
            }
        }
        return instance;
    }
}
```

**方案2：数据库约束**
```sql
CREATE TABLE singleton_instances (
    id INT PRIMARY KEY,
    instance_data TEXT,
    updated_time TIMESTAMP
);
```

### Q8: 工厂模式和依赖注入有什么关系？可以互相替代吗？

**A**: 两者关系和区别：

**相同点**：
- 都是为了解耦对象的创建和使用
- 都遵循依赖倒置原则

**不同点**：
- **工厂模式**：主动创建，调用方决定何时创建
- **依赖注入**：被动接收，容器负责创建和注入

**是否可以替代**：
- 在简单场景下可以替代
- 复杂场景下通常结合使用：
  - 用DI管理对象生命周期
  - 用工厂创建复杂对象

### Q9: 观察者模式如何避免内存泄漏？

**A**: 观察者模式容易导致内存泄漏，解决方法：

**问题代码**：
```java
// 错误示例：没有注销观察者
public class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void addObserver(Observer observer) {
        observers.add(observer); // 潜在内存泄漏
    }
}
```

**解决方案**：
```java
public class Subject {
    private WeakHashMap<Observer, Boolean> observers = new WeakHashMap<>();
    
    public void addObserver(Observer observer) {
        observers.put(observer, true); // 使用弱引用
    }
    
    public void removeObserver(Observer observer) {
        observers.remove(observer); // 主动移除
    }
    
    // 提供自动清理机制
    public void cleanup() {
        observers.entrySet().removeIf(entry -> entry.getKey() == null);
    }
}
```

### Q10: 装饰器模式和继承有什么区别？什么时候用哪个？

**A**: 区别和选择原则：

| 特性 | 装饰器模式 | 继承 |
|------|-------------|------|
| 灵活性 | 运行时动态添加 | 编译时静态确定 |
| 组合方式 | 对象组合 | 类继承 |
| 扩展性 | 无限扩展 | 受限于继承层次 |
| 复杂度 | 稍复杂 | 简单 |

**选择原则**：
- **用装饰器**：需要运行时动态添加功能、避免类爆炸
- **用继承**：功能固定、性能要求高、逻辑简单

**示例**：
```java
// 装饰器模式 - 动态组合
InputStream input = new BufferedInputStream(
    new DataInputStream(
        new FileInputStream("file.txt")
    )
);

// 继承 - 静态扩展
class ExtendedInputStream extends FileInputStream {
    // 固定功能扩展
}
```

## 🔧 技术细节类

### Q11: 如何保证设计模式的线程安全？

**A**: 不同模式的线程安全策略：

**单例模式**：
```java
// 双重检查锁定
public class ThreadSafeSingleton {
    private static volatile ThreadSafeSingleton instance;
    
    private ThreadSafeSingleton() {}
    
    public static ThreadSafeSingleton getInstance() {
        if (instance == null) {
            synchronized (ThreadSafeSingleton.class) {
                if (instance == null) {
                    instance = new ThreadSafeSingleton();
                }
            }
        }
        return instance;
    }
}
```

**观察者模式**：
```java
public class ThreadSafeSubject {
    private final List<Observer> observers = new CopyOnWriteArrayList<>();
    private final Object lock = new Object();
    
    public void notifyObservers() {
        List<Observer> snapshot;
        synchronized (lock) {
            snapshot = new ArrayList<>(observers);
        }
        for (Observer observer : snapshot) {
            observer.update();
        }
    }
}
```

### Q12: 设计模式会影响性能吗？如何优化？

**A**: 确实可能影响性能，优化策略：

**性能影响**：
- 增加对象创建开销
- 增加方法调用层次
- 可能产生更多小对象

**优化策略**：
1. **对象池化**：重用对象减少GC压力
2. **延迟初始化**：按需创建对象
3. **缓存机制**：缓存计算结果
4. **内联优化**：JVM自动优化小方法调用

**示例**：
```java
// 优化前：每次创建新对象
public class OptimizedFactory {
    public Product createProduct() {
        return new Product(); // 频繁创建
    }
}

// 优化后：对象池
public class OptimizedFactory {
    private final Queue<Product> pool = new ConcurrentLinkedQueue<>();
    
    public Product createProduct() {
        Product product = pool.poll();
        return product != null ? product : new Product();
    }
    
    public void returnProduct(Product product) {
        product.reset();
        pool.offer(product);
    }
}
```

### Q13: 在微服务架构中如何应用设计模式？

**A**: 微服务中的模式应用：

**服务发现模式**：
```java
// 代理模式实现服务发现
public class ServiceDiscoveryProxy implements RemoteService {
    private ServiceDiscovery discovery;
    private LoadBalancer loadBalancer;
    
    public Result call(String method, Object... args) {
        ServiceInstance instance = loadBalancer.select(
            discovery.getInstances("service-name")
        );
        return invokeRemote(instance, method, args);
    }
}
```

**断路器模式**：
```java
public class CircuitBreakerService {
    private CircuitBreaker circuitBreaker;
    
    public Result callService() {
        return circuitBreaker.executeSupplier(() -> {
            return remoteService.call();
        });
    }
}
```

**API网关模式**：
```java
// 外观模式实现API网关
public class ApiGateway {
    private UserService userService;
    private OrderService orderService;
    private PaymentService paymentService;
    
    public UserProfile getUserProfile(String userId) {
        User user = userService.getUser(userId);
        List<Order> orders = orderService.getUserOrders(userId);
        return new UserProfile(user, orders);
    }
}
```

## 🚀 进阶问题类

### Q14: 如何设计一个可扩展的框架？需要考虑哪些设计模式？

**A**: 设计可扩展框架的模式组合：

**核心模式组合**：
1. **工厂方法模式**：创建扩展点
2. **策略模式**：定义算法接口
3. **观察者模式**：事件通知机制
4. **模板方法模式**：定义处理流程
5. **装饰器模式**：功能增强

**框架设计示例**：
```java
// 模板方法定义处理流程
public abstract class FrameworkTemplate {
    public final Result process(Request request) {
        validate(request);
        Request enhanced = enhance(request);
        Result result = execute(enhanced);
        postProcess(result);
        return result;
    }
    
    protected abstract Result execute(Request request);
    protected void enhance(Request request) {
        // 装饰器模式增强请求
    }
}

// 工厂方法创建处理器
public interface ProcessorFactory {
    Processor createProcessor(String type);
}

// 策略模式定义不同处理策略
public interface ProcessingStrategy {
    Result process(Request request);
}
```

### Q15: 如何在代码审查中发现设计模式的应用问题？

**A**: 代码审查中的模式检查清单：

**过度设计检查**：
- [ ] 是否为了使用模式而使用模式？
- [ ] 简单问题是否用了复杂模式？
- [ ] 模式是否增加了不必要的复杂性？

**模式误用检查**：
- [ ] 单例模式是否真的需要全局唯一？
- [ ] 工厂模式是否只是简单的new操作？
- [ ] 观察者模式是否造成了循环依赖？

**实现质量检查**：
- [ ] 单例模式是否线程安全？
- [ ] 观察者模式是否正确注销？
- [ ] 装饰器模式是否保持了接口一致性？

**审查示例**：
```java
// 问题代码：过度使用抽象工厂
public class SimpleServiceFactory {
    public SimpleService createService() {
        return new SimpleService(); // 简单new，不需要工厂
    }
}

// 建议改进：直接使用
public class Client {
    public void doSomething() {
        SimpleService service = new SimpleService(); // 更简单直接
    }
}
```

## 📖 学习资源类

### Q16: 有哪些推荐的在线学习资源？

**A**: 优质在线资源推荐：

**官方网站**：
- [Refactoring.guru](https://refactoring.guru/) - 图解设计模式
- [SourceMaking](https://sourcemaking.com/) - 详细教程
- [Wikipedia Design Patterns](https://en.wikipedia.org/wiki/Software_design_pattern) - 权威定义

**视频资源**：
- YouTube: "Design Patterns Tutorial"
- B站: "设计模式详解"
- 慕课网: "Java设计模式精讲"

**实践项目**：
- Spring Framework源码
- JDK源码分析
- Apache Commons项目

### Q17: 如何参与设计模式相关的开源项目？

**A**: 参与方式：

**初学者**：
- 提交Issue报告问题
- 改进文档和注释
- 编写测试用例

**进阶开发者**：
- 提交代码改进
- 实现新的功能特性
- 代码审查和讨论

**贡献者**：
- 设计新功能
- 架构改进建议
- 社区推广

---

如果你有其他问题，欢迎在GitHub Discussions中提出，我们会持续更新这个FAQ文档！